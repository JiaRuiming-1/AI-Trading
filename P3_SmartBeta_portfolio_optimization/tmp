def rebalance_portfolio(returns, index_weights, shift_size, chunk_size):
    """
    Get weights for each rebalancing of the portfolio.

    Parameters
    ----------
    returns : DataFrame
        Returns for each ticker and date
    index_weights : DataFrame
        Index weight for each ticker and date
    shift_size : int
        The number of days between each rebalance
    chunk_size : int
        The number of days to look in the past for rebalancing

    Returns
    -------
    all_rebalance_weights  : list of Ndarrays
        The ETF weights for each point they are rebalanced
    """
    assert returns.index.equals(index_weights.index)
    assert returns.columns.equals(index_weights.columns)
    assert shift_size > 0
    assert chunk_size >= 0
    
#     all_rebalance_weights = []
#     for i, sub_returns in enumerate(returns.rolling(window=chunk_size)):
#         if i >= chunk_size-1 and (i-chunk_size-1)%shift_size==0:
#             chunk_covariance_returns = get_covariance_returns(sub_returns.copy())
#             all_rebalance_weights.append(get_optimal_weights(chunk_covariance_returns, index_weights.iloc[i].copy()))

#     return all_rebalance_weights
    all_rebalance_weights = []
    all_rebalance_returns = pd.DataFrame()
    for shift in range(chunk_size, len(returns), shift_size):
        start_idx = shift - chunk_size
        covariance_returns = get_covariance_returns(returns.iloc[start_idx:shift])
        optimal_weights = get_optimal_weights(covariance_returns, index_weights.iloc[shift-1])
        all_rebalance_weights.append(optimal_weights)
        all_rebalance_returns = all_rebalance_returns.append(returns.iloc[start_idx:shift] * optimal_weights)
    all_rebalance_returns = all_rebalance_returns[~all_rebalance_returns.index.duplicated(keep='first')]
    return all_rebalance_weights, all_rebalance_returns

# project_tests.test_rebalance_portfolio(rebalance_portfolio)

chunk_size = 250
shift_size = 5
all_rebalance_weights, all_rebalance_returns = rebalance_portfolio(returns, index_weights, shift_size, chunk_size)

optim_cumulative_returns = calculate_cumulative_returns(all_rebalance_returns)
project_helper.plot_benchmark_returns(index_weighted_cumulative_returns,optim_cumulative_returns, 'Optimized weights vs Index')

optim_etf_tracking_error = tracking_error(np.sum(index_weighted_returns, 1)[:-4], np.sum(all_rebalance_returns, 1))
print('Optimized ETF Tracking Error: {}'.format(optim_etf_tracking_error))
